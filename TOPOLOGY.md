# LACCHAIN TOPOLOGY AND ARCHITECTURE

The purpose of this documentation is to give a scope of the network topology in LACCHAIN, as well as the architecture, communication and security in LACCHAIN Network.

## Topology

The nodes of LACChain DLT public-permissioned networks can be classified into two groups, according to their participation in the maintenance of the network. In each of this two groups there are also two different types of nodes, according to the specific role of the node in the network. 

In the following image we can see the topology and the different connections

![LACCHAIN Topology](/docs/images/topology.png)

### Core nodes

Core nodes play an important role in the correct functioning of the network. The network cannnot work without them. Core nodes are classified into validator and gear nodes.

* **Validator nodes**

    Validator nodes are those that participate of the consensus protocol, hashing transactions and proposing new blocks. Validator nodes are only connected to each other and to gear nodes.

* **Gear nodes**

    Gear nodes are those that act as a liaison between validator and satellite nodes. They update the satellite nodes about the new blocks generated by the validator nodes and update the validator nodes about the transactions broadcasted by the writer nodes. They are also responsible for setting up new nodes, updating them with the most updated version of the blockchain and other required information such as whitelists and blacklists.

    Gear nodes are connected to all the nodes in the network.

### Satellite nodes

Satellite nodes do not play a direct role in the correct functioning of the network. The network works without them. Satellite nodes are classified into writer and observer nodes.

* **Writer nodes**

    Writer nodes are those that generate the transactions to be recorded in the network. They communicate the transactions to the gear nodes, which pass it along to the validator nodes. They can also create private channels between themselves for private communication.

    Writer nodes are connected to gear nodes and to other satellite nodes.

* **Observer nodes**

    Observer nodes are those that can only read the blockchain.

    Observer nodes only connected to gear nodes.

## Architecture

In peer-to-peer systems, each peer or client can directly send and receive data directly from any other client. Each of the peers in the network behaves both as a server and as a client. Each node can request data to be saved in some nodes database, or it can request to read from a node’s database. In Lacchain, all nodes can request from another node some information, about Lacchain’s current state (smart contract, account balance, last block etc.). The node knows that some information is correct and valid because it can be verified it with Lacchain’s consensus protocol.

LACCHAIN is based on Peer to Peer networks. These networks have many advantages against Client-Server Architecture, the following table shows some advantages:

<br>

|Client Server     |Peer-to-Peer|
|-----------|-----------|
|1. Server is the central entity and only<br> provider of service and content.<br>Network managed by the server<br>2. Server as the higher performance<br> system<br>3. Clients as the lower performance system<br><br>**Example: WWW** |1. Resources are shared between the peers<br> 2. Resources can be accessed directly from<br> other peers<br> 3. Peer is provider and requestor<br> 4. Any peer can be removed without loss of <br>overall functionality<br> 5. No central entities<br><br> **Example: Ethereum, Lacchain**|

In addition to being a peer to peer network, Lacchain is deployed using [Hyperledger Besu](https://www.hyperledger.org/projects/besu "Hyperledger Besu"), which is a Ethereum enterprise client. 

As Lacchain is based on Ethereum, it network architecture has two stacks. A Discovery Stack to discover existing nodes in the network and Connection Stack to send messages or communicate with other nodes in the network. 

![LACCHAIN Stacks](/docs/images/stacks.png)

### Node Discovery

To make a p2p network complete, there must be an implementation of node discovery, which allows peers to discover more nodes that support and run an lacchain validator, gear or writer node.

Discovery is used to build the peer to peer network and it's a protocol based in Kademlia.

Kademlia is a well-defined distributed hash table. Ethereum uses Kademlia because is a well-defined standard and protocol. You can see more about [Kademlia](https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf "Kademlia paper"). 

Lacchain uses only the discovery part from Kademlia protocol.
If you need more information on how ethereum implements Kademlia, you could check [here](https://github.com/ethereum/wiki/wiki/Kademlia-Peer-Selection "Kademlia in Ethereum").

To begin the discovery process the node needs an identity. the identity of the node is achieved through an enodeID, wich is then hashed with [SHA3](https://en.bitcoinwiki.org/wiki/SHA-3 "SHA3") into 256-bit value. you can review [node identity](https://github.com/ethereum/devp2p/blob/master/rlpx.md#node-identity "node-identity") to know more about this.

Next, Lacchain uses **UDP** protocol to exchange information about the P2P network. The steps to achieve the discovery of nodes in the network are the following:

* PING: A PING message is sent by the new node that solicits a PONG message in return. This pair of messages is used to determine whether a neighboring node is responsive.

* FIND_NEIGHBOURS: A findnode message is sent by the new node that solicits a neighbors message that contains a list of 16 nodes that have been seen by the responding node.

![P2P Network](/docs/images/discovery.png)

In Lacchain when a new node tries to join the network, it needs to establish a list of some known peers that it can communicate with. To do so, address of gears nodes are hard-coded in Lacchain network. Upon joining the network for the first time, the new node will ask one of these bootstrap peers for a list of active nodes. So whenever a peer tries to contact a node besides one of these bootnodes, it will work.

To summarize, the discovery process to join a node to the lacchain network is as follows:
* Get a enode ID.
* Connect to boot nodes.
* Bond to them:
    * Send Ping
    * On Pong do a findNeighbours
* Table of new node is persisted to minimise bootstrap requirements

### Node Communication

Communication between nodes works once the node have discovered other nodes in Lacchain network. Communication is related to send messages to other nodes.

For data transfer, Lacchain uses a protocol named RLPx. RLPx enables nodes to transfer encrypted and serialized data.

RLPx provides the encrypted multiplexed messaging. The multiplex is just a fancy way of saying each message has at the start, a indicator of what type of message it is. 

When two nodes want to communicate, they send each other some cryptographic data (public keys and such) to make sure all of the subsequent data transfer is encrypted (using ECDH, ECDHE, ECIES and more elliptic curve cryptography) and cryptographically signed (you can learn more about elliptic curve cryptography [here](https://hackernoon.com/what-is-the-math-behind-elliptic-curve-cryptography-f61b25253da3 "elliptic curve")). 

Then, both nodes send to each other which protocols and which versions of these protocols they support: The Ethereum protocol is “eth,” Ethereum’s Whisper protocol is “shh”, and the Light Ethereum Node Subprotocol is “les.”

After all messages are encrypted and a protocol agreed upon, the subsequent messages are dependant on the protocol chosen. 

look at [RLPx](https://github.com/ethereum/devp2p/blob/master/rlpx.md "RLPx") to better understand the entire process.

### Transactions

Transaction is the way the external world interacting with the Lacchain network. Transaction is used when we wish to modify or update the state stored in the Lacchain network.

The transaction cycle is:

At First your local(writer) node will then validate the signed transaction to make sure that it was really signed by this account address.

Next, the signed transaction is broadcast by your writer node to it’s peers who in turn broadcast to their peers and so on. Once the transaction is broadcast to the network, your local node also outputs the transaction id which you can use to track the status of your transaction. This transaction id is just the hash of the signed transaction object.

After, validator nodes maintain a transaction pool where your transaction gets added to before they start evaluating it.

![Tx Pool](/docs/images/tx_pool.png)

The validator picks our transaction to include in the block along with other transactions. The validator can only pick so many transactions to include in the block because Lacchain has set a block gas limit.

Once the miners select the transactions to include in the block, the transactions are validated and included in a pending block and the Proof IBFT2 begins. One of the validators nodes adds that block to the blockchain. Just like the raw transaction was broadcast by your local node which was received by all other nodes, the validator node broadcasts this valid block to other nodes.

Eventually your local node will receive this new block and syncs it’s local copy of the blockchain. Upon receiving the new block, the local node executes all the transactions in the block.